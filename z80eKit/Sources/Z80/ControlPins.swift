//
//  File.swift
//  
//
//  Created by Christophe Bronner on 2024-03-18.
//

import EmulationKit

public struct ControlPins: OptionSet {
	public var rawValue: UInt16

	@inlinable
	public init(rawValue: UInt16) {
		self.rawValue = rawValue
	}
}

//MARK: - Pins

extension ControlPins {

	/// BUS ACKnowledge (output, active Low), indicates to the requesting device that the CPU address bus, data bus, and control signals MREQ, IORQ, RD, and WR have entered their high-impedance states. The external circuitry can now control these lines.
	public static let busack = Self(rawValue: 0x1)

	/// BUS REQuest (input, active Low). Bus Request contains a higher priority than NMI and is always recognized at the end of the current machine cycle.
	///
	/// BUSREQ forces the CPU address bus, data bus, and control signals MREQ, IORQ, RD, and WR to enter a high-impedance state so that other devices can control these lines.
	/// BUSREQ is normally wired OR and requires an external pull-up for these applications.
	/// Extended BUSREQ periods due to extensive DMA operations can prevent the CPU from properly refreshing dynamic RAM
	public static let busreq = Self(rawValue: 0x2)

	/// HALT. HALT State (output, active Low). HALT indicates that the CPU has executed a HALT instruction and is waiting for either a nonmaskable or a maskable interrupt (with the mask enabled) before operation can resume. During HALT, the CPU executes NOPs to maintain memory refreshes.
	public static let halt = Self(rawValue: 0x4)

	/// INT. Interrupt Request (input, active Low). An Interrupt Request is generated by I/O devices.
	///
	/// The CPU honors a request at the end of the current instruction if the internal software-controlled interrupt enable flip-flop (IFF) is enabled.
	/// INT is normally wired-OR and requires an external pull-up for these applications.
	public static let int = Self(rawValue: 0x8)

	/// IORQ. Input/Output Request (output, active Low, tristate). IORQ indicates that the lower half of the address bus holds a valid I/O address for an I/O read or write operation.
	/// IORQ is also generated concurrently with M1 during an interrupt acknowledge cycle to indicate that an interrupt response vector can be placed on the data bus.
	public static let iorq = Self(rawValue: 0x10)

	/// M1. Machine Cycle One (output, active Low). M1, together with MREQ, indicates that the current machine cycle is the op code fetch cycle of an instruction execution.
	///
	/// M1, when operating together with IORQ, indicates an interrupt acknowledge cycle.
	public static let m1 = Self(rawValue: 0x20)

	/// MREQ. Memory Request (output, active Low, tristate). MREQ indicates that the address bus holds a valid address for a memory read or a memory write operation.
	public static let mreq = Self(rawValue: 0x40)

	/// NMI. Nonmaskable Interrupt (input, negative edge-triggered). NMI contains a higher priority than INT.
	///
	/// NMI is always recognized at the end of the current instruction, independent of the status of the interrupt enable flip-flop, and automatically forces the CPU to restart at location 0066h.
	public static let nmi = Self(rawValue: 0x80)

	/// RD. Read (output, active Low, tristate). RD indicates that the CPU wants to read data from memory or an I/O device. The addressed I/O device or memory should use this signal to gate data onto the CPU data bus.
	public static let read = Self(rawValue: 0x100)

	/// RESET. Reset (input, active Low).
	///
	/// RESET initializes the CPU as follows: it resets the interrupt enable flip-flop, clears the Program Counter and registers I and R, and sets the interrupt status to Mode 0.
	/// During reset time, the address and data bus enter a high-impedance state, and all control output signals enter an inactive state.
	/// RESET must be active for a minimum of three full clock cycles before a reset operation is complete.
	public static let reset = Self(rawValue: 0x200)

	/// RFSH. Refresh (output, active Low). RFSH, together with MREQ, indicates that the lower seven bits of the system’s address bus can be used as a refresh address to the system’s dynamic memories
	public static let rfsh = Self(rawValue: 0x400)

	/// WAIT. WAIT (input, active Low).
	///
	/// WAIT communicates to the CPU that the addressed memory or I/O devices are not ready for a data transfer.
	/// The CPU continues to enter a WAIT state as long as this signal is active.
	/// Extended WAIT periods can prevent the CPU from properly refreshing dynamic memory.
	public static let wait = Self(rawValue: 0x800)

	/// WR. Write (output, active Low, tristate). 
	///
	/// WR indicates that the CPU data bus contains valid data to be stored at the addressed memory or I/O location.
	public static let wr = Self(rawValue: 0x1000)

	/// CLK. Clock (input). Single-phase MOS-level clock.
	public static let clk = Self(rawValue: 0x2000)

}

//MARK: - Activity Status

extension ControlPins {

	/// Whether ``Z80ControlFlags/busack-type.property`` is currently active.
	@inlinable
	public var busack: Bool {
		get { !rawValue.bits[0] }
		set { rawValue.bits[0] = !newValue }
	}

	/// Whether ``Z80ControlFlags/busreq-type.property`` is currently active.
	@inlinable
	public var busreq: Bool {
		get { !rawValue.bits[1] }
		set { rawValue.bits[1] = !newValue }
	}

}
